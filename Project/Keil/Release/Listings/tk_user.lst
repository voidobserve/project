C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TK_USER
OBJECT MODULE PLACED IN .\Release\Objects\tk_user.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\tk_user.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware;..\..\Lowpower;..\..\App) INTERVAL(3) DEBUG OBJECTE
                    -XTEND PRINT(.\Release\Listings\tk_user.lst) OBJECT(.\Release\Objects\tk_user.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    User/tk_user.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    05-20-2022
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2022 TAIXIN-IC</center></h2>
  12           *
  13           *
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include "include.h"
  20          #include "my_config.h"
  21          
  22          /** @addtogroup Template_Project
  23           * @{
  24           */
  25          
  26          /* Private typedef -----------------------------------------------------------*/
  27          /* Private define ------------------------------------------------------------*/
  28          /* Private macro -------------------------------------------------------------*/
  29          /* Private variables ---------------------------------------------------------*/
  30          /* Private function prototypes -----------------------------------------------*/
  31          /* Private functions ---------------------------------------------------------*/
  32          
  33          #ifdef DEVELOPMENT_BOARD
              /**
               * @brief  Touchkey  debug uart init function
               * @param  None
               * @retval None
               */
              xdata u16 led_data[1];                           // LED显示buff
              #define LED_DIS_FREQ (1000000 / 16 / 8 / 60 - 1) // 一个CON的显示时间60Hz    60-1=1M/(LED_COMCON*16*LED_TI
             -ME_CON)
              
              unsigned int xdata display_data = 0;
              #endif // #ifdef DEVELOPMENT_BOARD
  44          
  45          /**
  46           * @brief  调试接口IO初始化函数.
  47           * @param  None
  48           * @retval None
  49           */
  50          #if TK_DEBUG_EN
              void debug_gpio_config(void)
              {
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 2   

              #if 1
                  P2_MD0 &= ~GPIO_P21_MODE_SEL(0x03);
                  P2_MD0 |= GPIO_P21_MODE_SEL(0x01);
                  FOUT_S21 = GPIO_FOUT_UART1_TX;
              #else
                  P2_MD1 &= ~GPIO_P27_MODE_SEL(0x03);
                  P2_MD1 |= GPIO_P27_MODE_SEL(0x01);
                  FOUT_S27 = GPIO_FOUT_UART1_TX;
              #endif
              }
              #endif
  64          
  65          #ifdef DEVELOPMENT_BOARD
              /**
               * @brief  LED INIT FUNCTION
               * @param  None
               * @retval None
               */
              // 在开发板上：
              // P2_7连接到四个蓝色LED的负极的公共端
              // P0_3连接到LED1正极
              // P3_0连接到LED2正极
              // P1_0连接到LED3正极
              // P0_7连接到LED4正极
              void led_init(void)
              {
                  // 配置COM0   P27为输出模式
                  // P2_MD1，P2的工作模式寄存器1
                  P2_MD1 &= ~GPIO_P27_MODE_SEL(0x3); // 清零P2_MD1寄存器的6-7位
                  P2_MD1 |= GPIO_P27_MODE_SEL(0x1);  // P2_MD1的6~7位设置为0x01，这样会将P2的第7个IO设置为输出模式
              
                  // 配置IO的驱动能力
                  // P2的第7个IO的驱动电流为8mA
                  P2_DRV7 = GPIO_P27_DRV_SEL(0x1);
              
                  // 配置SEG0-SEG4 P03\P30\P10\P07-输出模式
                  // P0_3、P3_0、P1_0和P0_1配置为输出模式
                  // 下面是先清零，再置位的操作
                  P0_MD0 &= ~GPIO_P03_MODE_SEL(0x3);
                  P3_MD0 &= ~GPIO_P30_MODE_SEL(0x3);
                  P1_MD0 &= ~GPIO_P10_MODE_SEL(0x3);
                  P0_MD1 &= ~GPIO_P07_MODE_SEL(0x3);
              
                  P0_MD0 |= GPIO_P03_MODE_SEL(0x1);
                  P3_MD0 |= GPIO_P30_MODE_SEL(0x1);
                  P1_MD0 |= GPIO_P10_MODE_SEL(0x1);
                  P0_MD1 |= GPIO_P07_MODE_SEL(0x1);
              
                  // SEG0-SEG4 P03\P30\P10\P07
                  // 配置P0_3、P3_0、P1_0和P0_1的输出功能，驱动LED（应该是连接到了片上外设LED模块，这个模块是个控制器）
                  FOUT_S03 = GPIO_FOUT_LED_SEG0;
                  FOUT_S30 = GPIO_FOUT_LED_SEG1;
                  FOUT_S10 = GPIO_FOUT_LED_SEG2;
                  FOUT_S07 = GPIO_FOUT_LED_SEG3;
              
                  // 配置P0_3、P3_0、P1_0和P0_1的输出电流，8mA
                  P0_DRV3 = GPIO_P03_DRV_SEL(0x1);
                  P3_DRV0 = GPIO_P30_DRV_SEL(0x1);
                  P1_DRV0 = GPIO_P10_DRV_SEL(0x1);
                  P0_DRV7 = GPIO_P07_DRV_SEL(0x1);
              
                  // COM0 P27
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 3   

                  // 配置P2_7的输出功能，连接到LED的公共端0
                  FOUT_S27 = GPIO_FOUT_LED_COM0;
              
                  CLK_CON2 |= CLK_LED_EN(0x1); // 打开LED模块的时钟（打开片上外设LED模块的时钟）
              
                  // 0x55表示允许访问和设置 wdt_psr（在WDT_CON中，psr表示看门狗定时时间）
                  WDT_KEY = 0x55;                // 操作IO_MAP寄存器需要写KEY
                  IO_MAP |= MAP_LED_DMA_EN(0x1); // LED DMA使能
                  WDT_KEY = 0xBB;                // 写入一个错误的数值，恢复该寄存器的写保护
              
                  // 打开LED模块的时钟
                  CLK_CON2 |= 0x10;
              
                  LED_SEGCONL = LED_SEG0_EN(0x1) | // SEG0 使能
                                LED_SEG1_EN(0x1) | // SEG0 使能
                                LED_SEG2_EN(0x1) | // SEG0 使能
                                LED_SEG3_EN(0x1);  // SEG0 使能
                  LED_COMCON = LED_COM0_EN(0x1);   // COM1 使能
              
                  LED_DMAADRH = LED_DMA_ADDR_H((((u16)led_data) >> 8) & 0xFF); // LED数据储存首地址的高8位
                  LED_DMAADRL = LED_DMA_ADDR_L((((u16)led_data) >> 0) & 0xFF); // LED数据储存首地址的低8位
                  LED_TIMECON = LED_SCAN_TIME(LED_DIS_FREQ);                   // 扫描到某个com或seg时点亮的时间,步长为3
             -2微秒
                  LED_CON = LED_COM_SEG_SEL(0x0) |                             // 扫描方式选择com扫描
                            LED_EN(0x1);                                       // LED使能,使能之后从DMAADDRH和DMAADDRL的
             -地址开始拿数据扫描点亮,用户将数据写到对应的地址即可
              
                  led_data[0] = 0x00000f00; // 一开始让四个LED全部点亮
                  // led_data[0] = 0x00000000; // 一开始让四个LED全部熄灭
              }
              
              void led_display(void)
              {
                  led_data[0] = display_data;
              }
              #endif // #ifdef DEVELOPMENT_BOARD
 149          
 150          /**
 151           * @brief  用户代码初始化函数接口.
 152           * @param  None
 153           * @retval None
 154           */
 155          void user_init(void)
 156          {
 157   1          // led_init(); // 初始化开发板LED相关的引脚
 158   1      
 159   1      #ifdef DEVELOPMENT_BOARD // demo板上使用串口0来作为调试
                  uart0_config();      // 调试用到的串口
                  p24_output_config(); // 调试用的，观察引脚的电平变化
              #endif                   // demo板上使用串口0来作为调试
 163   1      
 164   1          uart1_config(); // 单线通信的配置
 165   1          tmr2_config();  // 定时器2的配置，配置完成后，默认是关闭的
 166   1          knob_config();  // 旋钮的配置
 167   1          // tmr2_enable();
 168   1      
 169   1      #if USE_MY_DEBUG
                  // p25_output_config(); //
              #endif // USE_MY_DEBUG
 172   1      }
 173          
 174          #ifdef DEVELOPMENT_BOARD // 开发板上对应额触摸按键函数接口
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 4   

              /**
               * @brief  用户代码循环执行函数接口.（触摸按键扫描函数接口）
               * @param  None
               * @retval None
               */
              void user_handle(void)
              {
                  volatile unsigned long int KeyOnOutput = __tk_key_flag; // __tk_key_flag单次按键标志
                  static volatile unsigned long int KeyOld = 0;           // 用于存放长按时，对应的按键
              
                  // 是否长按的标志，0--否，1--是
                  // 需要保存长按的状态，表示定时器一直在发送键值
                  static unsigned char long_touch_flag = 0; // 上一次扫描到的按键是否为长按的标志
                  static volatile u32 cnt = 0;              // 长按计数值
              
                  u32 i = 0; // 循环计数值
              
                  if (KeyOnOutput && 0 == long_touch_flag && cnt < TK_LONG_KEY_TIME) // 如果有按键按下（并且之前扫描到的
             -不是长按）
                  {
              #if 1
                      // 通过循环判断是否为长按
                      for (i = 0; i < 500000; i++) // 实际上用不到这么大的数字，到了设定的长按时间就会退出
                      {
                          // 按键扫描函数，使用了库里面的接口（闭源库）
                          // 这个函数会更新__tk_key_flag的值
                          delay_ms(10);
                          __tk_scan();
              
                          if (KeyOnOutput == __tk_key_flag)
                          {
                              // 如果按键键值一致，说明按键一直被按下，未松开
                              cnt++;
              
                              if (TK_CH0_VALIB == KeyOnOutput)
                              {
                                  printf("检测到按键1按下，并且还处于是否长按的判定中\n");
                              }
                              else
                              {
                                  // 如果是其他按键，不用检测长按
                                  break;
                              }
                          }
                          else
                          {
                              // 如果按键键值不一致或是松开了按键
                              break;
                          }
                          if (cnt > TK_LONG_KEY_TIME) // 如果长按超过了这里设置的时间
                          {
                              long_touch_flag = 1; // 标记为长按
                              break;
                          }
                      }
              #endif
              
                      if (cnt > TK_LONG_KEY_TIME)
                      {
                          long_touch_flag = 1; // 标记为长按
                      }
                      else
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 5   

                      {
                          // 如果是短按
                          cnt = 0; // 清除长按的计数值
              
                          // 判断当前触摸的键值，做对应的操作
                          if (TK_CH0_VALIB == KeyOnOutput)
                          {
              
                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                              while (0 != KeyOnOutput)
                              {
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
                                  // 按键不松开，就一直发送数据
                                  //  send_key_status(TOUCH_KEY_BULETOOTH);
                                  printf("按键1按下\n");
                              }
              
                              // 按键松开时，再提示按键按下的信息
                              printf("按键1按下并松开\n");
                              is_touch_key_light_press = 1;
              
                              return;
                          }
                          else if (TK_CH4_VALIB == KeyOnOutput)
                          {
                              // 如果开发板的TK2被触摸
                              // display_data ^= 0x0200; // 对应的LED状态取反，后面会调用led_display()刷新
                              for (i = 0; i < 300; i++)
                              {
                                  delay_ms(1);
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
              
                                  if (TK_CH4_VALIB == KeyOnOutput)
                                  {
                                      // 如果检测到是同一个按键按下，说明是双击
                                      // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                                      while (0 != KeyOnOutput)
                                      {
                                          __tk_scan();
                                          KeyOnOutput = __tk_key_flag;
                                      }
              
                                      // send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK2);
                                      return;
                                  }
                              }
              
                              // 如果不是同一个按键按下或是没有值，说明是短按
                              // send_status_keyval(KEY_PRESS_SHORT, KEY_TK2); // 发送带有状态的键值
                          }
                          else if (TK_CH5_VALIB == KeyOnOutput)
                          {
                              // 如果开发板的TK3被触摸
                              // display_data ^= 0x0400; // 对应的LED状态取反，后面会调用led_display()刷新
                              for (i = 0; i < 300; i++)
                              {
                                  delay_ms(1);
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
              
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 6   

                                  if (TK_CH5_VALIB == KeyOnOutput)
                                  {
                                      // 如果检测到是同一个按键按下，说明是双击
                                      // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                                      while (0 != KeyOnOutput)
                                      {
                                          __tk_scan();
                                          KeyOnOutput = __tk_key_flag;
                                      }
              
                                      // send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK3);
                                      return;
                                  }
                              }
              
                              // 如果不是同一个按键按下或是没有值，说明是短按
                              // send_status_keyval(KEY_PRESS_SHORT, KEY_TK3); // 发送带有状态的键值
                          }
                          else if (TK_CH6_VALIB == KeyOnOutput)
                          {
                              // 如果开发板的TK4被触摸
                              // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
                              for (i = 0; i < 300; i++)
                              {
                                  delay_ms(1);
                                  __tk_scan();
                                  KeyOnOutput = __tk_key_flag;
              
                                  if (TK_CH6_VALIB == KeyOnOutput)
                                  {
                                      // 如果检测到是同一个按键按下，说明是双击
                                      // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
                                      while (0 != KeyOnOutput)
                                      {
                                          __tk_scan();
                                          KeyOnOutput = __tk_key_flag;
                                      }
              
                                      // send_status_keyval(KEY_PRESS_DOUBLECLICK, KEY_TK4);
                                      return;
                                  }
                              }
              
                              // 如果不是同一个按键按下或是没有值，说明是短按
                              // send_status_keyval(KEY_PRESS_SHORT, KEY_TK4); // 发送带有状态的键值
                          }
                      }
                  }
              
              #if 1
                  if (1 == long_touch_flag && 0 != KeyOnOutput)
                  {
                      KeyOld = KeyOnOutput;
              
                      // 如果之前是长按，现在还未松开
                      // 判断当前触摸的键值，做对应的操作
                      if (TK_CH0_VALIB == KeyOnOutput)
                      {
                          // 如果开发板的TK1被触摸
                          if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
                          {
                              printf("按键1长按\n");
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 7   

                          }
              
              #if USE_MY_DEBUG
                          P24 = ~P24;
              #endif // USE_MY_DEBUG
              
                          // 若还不松开手
                          while (0 != KeyOnOutput)
                          {
                              __tk_scan();
                              KeyOnOutput = __tk_key_flag;
              
                              // 进行灯光调节
                              if (LIGHT_CTL_MODE_SINGLE == light_ctl_mode)
                              {
                                  // 如果当前是单色模式（只控制白灯）
                                  if (light_adjust_add_sub_flag)
                                  {
                                      // 如果当前是在增大亮度
                                      if (cur_pwm_duty < PWM_MAX_DUTY_SINGLE_LIGHT)
                                      {
                                          tmr1_set_pwm_duty(++cur_pwm_duty);
                                          white_light_open();
                                      }
                                      else
                                      {
                                          // 如果已经到了最大亮度
                                          // cur_pwm_duty = 700;
                                          tmr1_set_pwm_duty(cur_pwm_duty);
                                          white_light_open();
              #if USE_MY_DEBUG
                                          P24 = ~P24;
              #endif // USE_MY_DEBUG
                                      }
              
                                      light_on_off_status = 1; // 更新灯光状态
                                  }
                                  else
                                  {
                                      // 如果当前是在减小亮度
                                      if (cur_pwm_duty > 0)
                                      {
                                          tmr1_set_pwm_duty(--cur_pwm_duty);
                                          white_light_open();
              
                                          light_on_off_status = 1; // 更新灯光状态
                                      }
                                      else
                                      {
                                          // 如果已经到了最小亮度
                                          // cur_pwm_duty = 0;
                                          tmr1_set_pwm_duty(cur_pwm_duty);
                                          white_light_close();
              
                                          light_on_off_status = 0; // 更新灯光状态
              #if USE_MY_DEBUG
                                          P24 = ~P24;
              #endif // USE_MY_DEBUG
                                      }
                                  }
                              }
                              else if (LIGHT_CTL_MODE_MUILTY == light_ctl_mode)
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 8   

                              {
                                  // 如果当前是三色切换模式
                                  // 判断当前是不是黄白色，如果是，需要注意最大的占空比为60%，如果不是，最大的占空比为70
             -%
              
                                  if (LIGHT_MUILTY_CUR_WHITE == light_muilty_cur_status)
                                  {
                                      // 如果当前是白灯
                                      if (light_adjust_add_sub_flag)
                                      {
                                          // 如果当前是在增大亮度
                                          if (cur_pwm_duty < PWM_MAX_DUTY_SINGLE_LIGHT)
                                          {
                                              tmr1_set_pwm_duty(++cur_pwm_duty);
                                              white_light_open();
                                          }
                                          else
                                          {
                                              // 如果已经到了最大亮度
                                              tmr1_set_pwm_duty(cur_pwm_duty);
                                              white_light_open();
              #if USE_MY_DEBUG
                                              P24 = ~P24;
              #endif // USE_MY_DEBUG
                                          }
              
                                          light_on_off_status = 1; // 更新灯光状态
                                      }
                                      else
                                      {
                                          // 如果当前是在减小亮度
                                          if (cur_pwm_duty > 0)
                                          {
                                              tmr1_set_pwm_duty(--cur_pwm_duty);
                                              white_light_open();
                                              light_on_off_status = 1; // 更新灯光状态
                                          }
                                          else
                                          {
                                              // 如果已经到了最小亮度
                                              tmr1_set_pwm_duty(cur_pwm_duty);
                                              white_light_close();
                                              light_on_off_status = 0; // 更新灯光状态
              #if USE_MY_DEBUG
                                              P24 = ~P24;
              #endif // USE_MY_DEBUG
                                          }
                                      }
                                  }
                                  else if (LIGHT_MUILTY_CUR_YELLOW == light_muilty_cur_status)
                                  {
                                      // 如果当前是黄灯
                                      if (light_adjust_add_sub_flag)
                                      {
                                          // 如果当前是在增大亮度
                                          if (cur_pwm_duty < PWM_MAX_DUTY_SINGLE_LIGHT)
                                          {
                                              tmr0_set_pwm_duty(++cur_pwm_duty);
                                              yellow_light_open();
                                          }
                                          else
                                          {
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 9   

                                              // 如果已经到了最大亮度
                                              tmr0_set_pwm_duty(cur_pwm_duty);
                                              yellow_light_open();
              #if USE_MY_DEBUG
                                              P24 = ~P24;
              #endif // USE_MY_DEBUG
                                          }
                                          light_on_off_status = 1; // 更新灯光状态
                                      }
                                      else
                                      {
                                          // 如果当前是在减小亮度
                                          if (cur_pwm_duty > 0)
                                          {
                                              tmr0_set_pwm_duty(--cur_pwm_duty);
                                              yellow_light_open();
                                              light_on_off_status = 1; // 更新灯光状态
                                          }
                                          else
                                          {
                                              // 如果已经到了最小亮度
                                              // cur_pwm_duty = 0;
                                              tmr0_set_pwm_duty(cur_pwm_duty);
                                              yellow_light_close();
                                              light_on_off_status = 0; // 更新灯光状态
              #if USE_MY_DEBUG
                                              P24 = ~P24;
              #endif // USE_MY_DEBUG
                                          }
                                      }
                                  }
                                  else if (LIGHT_MUILTY_CUR_YELLOW_WHITE == light_muilty_cur_status)
                                  {
                                      // 如果当前是黄白色
                                      if (light_adjust_add_sub_flag)
                                      {
                                          // 如果当前是在增大亮度
                                          if (cur_pwm_duty < PWM_MAX_DUTY_MUILTY_LIGHT)
                                          {
                                              tmr0_set_pwm_duty(++cur_pwm_duty);
                                              tmr1_set_pwm_duty(cur_pwm_duty);
                                              yellow_light_open();
                                              white_light_open();
                                          }
                                          else
                                          {
                                              // 如果已经到了最大亮度
                                              tmr0_set_pwm_duty(cur_pwm_duty);
                                              tmr1_set_pwm_duty(cur_pwm_duty);
                                              yellow_light_open();
                                              white_light_open();
              #if USE_MY_DEBUG
                                              P24 = ~P24;
              #endif // USE_MY_DEBUG
                                          }
                                          light_on_off_status = 1; // 更新灯光状态
                                      }
                                      else
                                      {
                                          // 如果当前是在减小亮度
                                          if (cur_pwm_duty > 0)
                                          {
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 10  

                                              tmr0_set_pwm_duty(--cur_pwm_duty);
                                              tmr1_set_pwm_duty(cur_pwm_duty);
                                              yellow_light_open();
                                              white_light_open();
                                              light_on_off_status = 1; // 更新灯光状态
                                          }
                                          else
                                          {
                                              // 如果已经到了最小亮度
                                              tmr0_set_pwm_duty(cur_pwm_duty);
                                              tmr1_set_pwm_duty(cur_pwm_duty);
                                              yellow_light_close();
                                              white_light_close();
                                              light_on_off_status = 0; // 更新灯光状态
              #if USE_MY_DEBUG
                                              P24 = ~P24;
              #endif // USE_MY_DEBUG
                                          }
                                      }
                                  }
                                  else if (LIGHT_MUILTY_CUR_OFF == light_muilty_cur_status)
                                  {
                                      // 如果当前灯是关闭的，松开手时，把灯打开
                                      is_touch_key_light_press = 1;
                                      light_adjust_add_sub_flag = 1;
                                      // return;
                                  }
                              }
              
                              // 在这里发送按键数据
                              delay_100us(15); // 每1.5ms调整0.1%的占空比
                          }
              
                          // 如果长按后松手了，要更新当前是在增大亮度还是减少亮度的标志位
                          if (light_adjust_add_sub_flag)
                          {
                              // 如果之前是在增大亮度，下次长按要变成减小亮度
                              light_adjust_add_sub_flag = 0; // 更新标志位
                          }
                          else
                          {
                              // 如果之前是在减小亮度，下次长按要变成增大亮度
                              light_adjust_add_sub_flag = 1; // 更新标志位
                          }
                      }
                  }
                  else if (1 == long_touch_flag && 0 == KeyOnOutput)
                  {
                      // 如果之前是长按，现在却松开了按键
                      switch (KeyOld)
                      {
                      case TK_CH0_VALIB:
                          printf("按键1长按后松开了按键\n");
                          // send_key_status(1, 0);
                          break;
              
                      case TK_CH4_VALIB:
                          // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK2);
                          break;
              
                      case TK_CH5_VALIB:
                          // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK3);
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 11  

                          break;
              
                      case TK_CH6_VALIB:
                          // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK4);
                          break;
                      }
              
                      long_touch_flag = 0; // 清除标志位
                      cnt = 0;
                      KeyOld = 0;
                  }
              #endif
              
                  // led_display(); // LED状态更新显示
              }
              #endif // end ifdef DEVELOPMENT_BOARD
 623          
 624          #ifdef CIRCUIT_BOARD // 目标电路板对应的触摸按键函数接口
 625          /**
 626           * @brief  用户代码循环执行函数接口.（触摸按键扫描函数接口）
 627           * @param  None
 628           * @retval None
 629           */
 630          void user_handle(void)
 631          {
 632   1          volatile unsigned long int KeyOnOutput = __tk_key_flag; // __tk_key_flag单次按键标志
 633   1          static volatile unsigned long int KeyOld = 0;           // 用于存放长按时，对应的按键
 634   1      
 635   1          // 是否长按的标志，0--否，1--是
 636   1          // 需要保存长按的状态，表示定时器一直在发送键值
 637   1          static unsigned char long_touch_flag = 0; // 上一次扫描到的按键是否为长按的标志
 638   1          static volatile u32 cnt = 0;              // 长按计数值
 639   1      
 640   1          u32 i = 0; // 循环计数值
 641   1      
 642   1          if (KeyOnOutput && 0 == long_touch_flag && cnt < TK_LONG_KEY_TIME) // 如果有按键按下（并且之前扫描到的
             -不是长按）
 643   1          {
 644   2              // 通过循环判断是否为长按
 645   2              for (i = 0; i < 500000; i++) // 实际上用不到这么大的数字，到了设定的长按时间就会退出
 646   2              {
 647   3                  // 按键扫描函数，使用了库里面的接口（闭源库）
 648   3                  // 这个函数会更新__tk_key_flag的值
 649   3                  delay_ms(10);
 650   3                  __tk_scan();
 651   3      
 652   3                  if (KeyOnOutput == __tk_key_flag)
 653   3                  {
 654   4                      // 如果按键键值一致，说明按键一直被按下，未松开
 655   4                      cnt++;
 656   4      
 657   4                      // 如果是灯光按键按下，继续发送按键的状态
 658   4                      if (TK_CH2_VALIB == KeyOnOutput)
 659   4                      {
 660   5                          send_key_status(TOUCH_KEY_LIGHT);
 661   5                      }
 662   4                      else
 663   4                      {
 664   5                          // 如果是其他按键，不用检测长按
 665   5                          break;
 666   5                      }
 667   4                  }
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 12  

 668   3                  else
 669   3                  {
 670   4                      // 如果按键键值不一致或是松开了按键
 671   4                      // cnt = 0;
 672   4                      break;
 673   4                  }
 674   3      
 675   3                  if (cnt > TK_LONG_KEY_TIME) // 如果长按超过了这里设置的时间
 676   3                  {
 677   4                      long_touch_flag = 1; // 标记为长按
 678   4                      break;
 679   4                  }
 680   3              }
 681   2      
 682   2              if (cnt > TK_LONG_KEY_TIME)
 683   2              {
 684   3                  long_touch_flag = 1; // 标记为长按
 685   3              }
 686   2              else
 687   2              {
 688   3                  // 如果是短按
 689   3                  cnt = 0; // 清除长按的计数值
 690   3      
 691   3                  // 判断当前触摸的键值，做对应的操作
 692   3                  if (TK_CH3_VALIB == KeyOnOutput)
 693   3                  {
 694   4                      // 如果触摸了按键--蓝牙
 695   4      
 696   4                      while (0 != KeyOnOutput)
 697   4                      {
 698   5                          __tk_scan();
 699   5                          KeyOnOutput = __tk_key_flag;
 700   5                          // 按键不松开，就一直发送数据
 701   5                          send_key_status(TOUCH_KEY_BULETOOTH);
 702   5                      }
 703   4      
 704   4                      // 按键松开，发送对应信息
 705   4                      // uart1_sendbyte(0x10);
 706   4                      // uart1_sendbyte(~0x10);
 707   4                      return;
 708   4                  }
 709   3                  else if (TK_CH2_VALIB == KeyOnOutput)
 710   3                  {
 711   4                      // 如果按键--灯被触摸
 712   4      
 713   4                      while (0 != KeyOnOutput)
 714   4                      {
 715   5                          __tk_scan();
 716   5                          KeyOnOutput = __tk_key_flag;
 717   5                          // 按键不松开，就一直发送数据
 718   5                          send_key_status(TOUCH_KEY_LIGHT);
 719   5                      }
 720   4      
 721   4                      // 按键松开，发送对应信息
 722   4                      // uart1_sendbyte(0x20);
 723   4                      // uart1_sendbyte(~0x20);
 724   4      
 725   4                      is_touch_key_light_press = 1; // 标志位置一
 726   4                      return;
 727   4                  }
 728   3                  else if (TK_CH0_VALIB == KeyOnOutput)
 729   3                  {
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 13  

 730   4                      // 如果按键--时钟被触摸
 731   4      
 732   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 733   4                      // send_status_keyval(KEY_PRESS_SHORT, KEY_TK3); // 发送带有状态的键值
 734   4      
 735   4                      while (0 != KeyOnOutput)
 736   4                      {
 737   5                          __tk_scan();
 738   5                          KeyOnOutput = __tk_key_flag;
 739   5                          // 按键不松开，就一直发送数据
 740   5                          send_key_status(TOUCH_KEY_CLOCK);
 741   5                      }
 742   4      
 743   4                      // 按键松开，发送对应信息
 744   4                      // uart1_sendbyte(0x30);
 745   4                      // uart1_sendbyte(~0x30);
 746   4                      return;
 747   4                  }
 748   3                  else if (TK_CH11_VALIB == KeyOnOutput)
 749   3                  {
 750   4                      // 如果按键--电源被触摸
 751   4      
 752   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 753   4                      // send_status_keyval(KEY_PRESS_SHORT, KEY_TK4); // 发送带有状态的键值
 754   4      
 755   4                      while (0 != KeyOnOutput)
 756   4                      {
 757   5                          __tk_scan();
 758   5                          KeyOnOutput = __tk_key_flag;
 759   5                          // 按键不松开，就一直发送数据
 760   5                          send_key_status(TOUCH_KEY_POWER);
 761   5                      }
 762   4      
 763   4                      // 按键松开，发送对应信息
 764   4                      // uart1_sendbyte(0x40);
 765   4                      // uart1_sendbyte(~0x40);
 766   4                      return;
 767   4                  }
 768   3                  else if (TK_CH10_VALIB == KeyOnOutput)
 769   3                  {
 770   4                      // 如果按键--减被触摸
 771   4      
 772   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 773   4                      // send_status_keyval(KEY_PRESS_SHORT, KEY_TK5); // 发送带有状态的键值
 774   4      
 775   4                      while (0 != KeyOnOutput)
 776   4                      {
 777   5                          __tk_scan();
 778   5                          KeyOnOutput = __tk_key_flag;
 779   5                          // 按键不松开，就一直发送数据
 780   5                          send_key_status(TOUCH_KEY_SUB);
 781   5                      }
 782   4      
 783   4                      // 按键松开，发送对应信息
 784   4                      // uart1_sendbyte(0x50);
 785   4                      // uart1_sendbyte(~0x50);
 786   4                      return;
 787   4                  }
 788   3                  else if (TK_CH9_VALIB == KeyOnOutput)
 789   3                  {
 790   4                      // 如果按键--加被触摸
 791   4      
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 14  

 792   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 793   4                      // send_status_keyval(KEY_PRESS_SHORT, KEY_TK6); // 发送带有状态的键值
 794   4      
 795   4                      while (0 != KeyOnOutput)
 796   4                      {
 797   5                          __tk_scan();
 798   5                          KeyOnOutput = __tk_key_flag;
 799   5                          // 按键不松开，就一直发送数据
 800   5                          send_key_status(TOUCH_KEY_ADD);
 801   5                      }
 802   4      
 803   4                      // 按键松开，发送对应信息
 804   4                      // uart1_sendbyte(0x60);
 805   4                      // uart1_sendbyte(~0x60);
 806   4                      return;
 807   4                  }
 808   3              }
 809   2          }
 810   1      
 811   1      #if 1 // 长按相关的功能
 812   1          if (1 == long_touch_flag && 0 != KeyOnOutput)
 813   1          {
 814   2              KeyOld = KeyOnOutput;
 815   2      
 816   2              // 如果之前是长按，现在还未松开
 817   2              // 判断当前触摸的键值，做对应的操作
 818   2              if (TK_CH2_VALIB == KeyOnOutput)
 819   2              {
 820   3                  // 如果 按键--灯光 被触摸
 821   3      
 822   3                  // 全局的长按标志位置一
 823   3                  // is_touch_key_light_hold = 1;
 824   3      
 825   3                  // 若还不松开手
 826   3                  while (0 != KeyOnOutput)
 827   3                  {
 828   4                      __tk_scan();
 829   4                      KeyOnOutput = __tk_key_flag;
 830   4      
 831   4      #if 1 // 进行长按的灯光调节
 832   4                      if (LIGHT_CTL_MODE_SINGLE == light_ctl_mode)
 833   4                      {
 834   5                          if (1 == light_on_off_status) // 只有灯亮时，才可以使用长按调节灯光
 835   5                          {
 836   6                              // 如果当前是单色模式（只控制白灯）
 837   6                              if (light_adjust_add_sub_flag)
 838   6                              {
 839   7                                  // 如果当前是在增大亮度
 840   7                                  if (cur_pwm_duty < PWM_MAX_DUTY_SINGLE_LIGHT)
 841   7                                  {
 842   8                                      tmr1_set_pwm_duty(++cur_pwm_duty);
 843   8                                      cur_white_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
 844   8                                  }
 845   7                                  else
 846   7                                  {
 847   8                                      // 如果已经到了最大亮度
 848   8                                      tmr1_set_pwm_duty(cur_pwm_duty);
 849   8                                  }
 850   7                              }
 851   6                              else
 852   6                              {
 853   7                                  // 如果当前是在减小亮度
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 15  

 854   7                                  if (cur_pwm_duty > PWM_MIN_DUTY_LIGHT)
 855   7                                  {
 856   8                                      tmr1_set_pwm_duty(--cur_pwm_duty);
 857   8                                      cur_white_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
 858   8                                  }
 859   7                                  else
 860   7                                  {
 861   8                                      // 如果已经到了最小亮度
 862   8                                      tmr1_set_pwm_duty(cur_pwm_duty);
 863   8                                  }
 864   7                              }
 865   6                          }
 866   5                          else if (0 == light_on_off_status)
 867   5                          {
 868   6                              // 如果当前灯是关闭的，松开手时，把灯打开
 869   6                              is_touch_key_light_press = 1;
 870   6                              light_adjust_add_sub_flag = 1;
 871   6                          }
 872   5                      }
 873   4                      else if (LIGHT_CTL_MODE_MUILTY == light_ctl_mode)
 874   4                      {
 875   5                          // 如果当前是三色切换模式
 876   5                          // 判断当前是不是黄白色，如果是，需要注意最大的占空比为60%，如果不是，最大的占空比为70
             -%
 877   5                          if (LIGHT_MUILTY_CUR_WHITE == light_muilty_cur_status)
 878   5                          {
 879   6                              // 如果当前是白灯
 880   6                              if (light_adjust_add_sub_flag)
 881   6                              {
 882   7                                  // 如果当前是在增大亮度
 883   7      
 884   7                                  // if (0 == light_on_off_status)
 885   7                                  // {
 886   7                                  //     // 如果此时灯光是灭的，打开灯光，并更新状态
 887   7                                  //     tmr1_set_pwm_duty(cur_pwm_duty);
 888   7                                  //     white_light_open();
 889   7      
 890   7                                  //     light_on_off_status = 1; // 更新灯光状态
 891   7                                  // }
 892   7      
 893   7                                  if (cur_pwm_duty < PWM_MAX_DUTY_SINGLE_LIGHT)
 894   7                                  {
 895   8                                      tmr1_set_pwm_duty(++cur_pwm_duty);
 896   8                                      cur_white_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
 897   8                                  }
 898   7                                  else
 899   7                                  {
 900   8                                      // 如果已经到了最大亮度
 901   8                                  }
 902   7                              }
 903   6                              else
 904   6                              {
 905   7                                  // 如果当前是在减小亮度
 906   7                                  if (cur_pwm_duty > PWM_MIN_DUTY_LIGHT)
 907   7                                  {
 908   8                                      tmr1_set_pwm_duty(--cur_pwm_duty);
 909   8                                      cur_white_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
 910   8                                  }
 911   7                                  else
 912   7                                  {
 913   8                                      // 如果已经到了最小亮度
 914   8                                      // tmr1_set_pwm_duty(cur_pwm_duty);
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 16  

 915   8                                      // white_light_close();
 916   8                                      // light_on_off_status = 0; // 更新灯光状态
 917   8                                  }
 918   7                              }
 919   6                          }
 920   5                          else if (LIGHT_MUILTY_CUR_YELLOW == light_muilty_cur_status)
 921   5                          {
 922   6                              // 如果当前是黄灯
 923   6                              if (light_adjust_add_sub_flag)
 924   6                              {
 925   7                                  // 如果当前是在增大亮度
 926   7      
 927   7                                  // if (0 == light_on_off_status)
 928   7                                  // {
 929   7                                  //     // 如果此时灯光是灭的，打开灯光，并更新状态
 930   7                                  //     tmr0_set_pwm_duty(cur_pwm_duty);
 931   7                                  //     yellow_light_open();
 932   7                                  //     light_on_off_status = 1; // 更新灯光状态
 933   7                                  // }
 934   7      
 935   7                                  if (cur_pwm_duty < PWM_MAX_DUTY_SINGLE_LIGHT)
 936   7                                  {
 937   8                                      tmr0_set_pwm_duty(++cur_pwm_duty);
 938   8                                      cur_yellow_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
 939   8                                  }
 940   7                                  else
 941   7                                  {
 942   8                                      // 如果已经到了最大亮度
 943   8                                  }
 944   7                              }
 945   6                              else
 946   6                              {
 947   7                                  // 如果当前是在减小亮度
 948   7                                  if (cur_pwm_duty > PWM_MIN_DUTY_LIGHT)
 949   7                                  {
 950   8                                      tmr0_set_pwm_duty(--cur_pwm_duty);
 951   8                                      cur_yellow_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
 952   8                                      // yellow_light_open();
 953   8                                      // light_on_off_status = 1; // 更新灯光状态
 954   8                                  }
 955   7                                  else
 956   7                                  {
 957   8                                      // 如果已经到了最小亮度
 958   8                                      // cur_pwm_duty = 0;
 959   8                                      // tmr0_set_pwm_duty(cur_pwm_duty);
 960   8                                      // yellow_light_close();
 961   8                                      // light_on_off_status = 0; // 更新灯光状态
 962   8                                  }
 963   7                              }
 964   6                          }
 965   5                          else if (LIGHT_MUILTY_CUR_YELLOW_WHITE == light_muilty_cur_status)
 966   5                          {
 967   6                              // 如果当前是黄白色
 968   6                              if (light_adjust_add_sub_flag)
 969   6                              {
 970   7                                  // 如果当前是在增大亮度
 971   7      
 972   7                                  // if (0 == light_on_off_status)
 973   7                                  // {
 974   7                                  //     // 如果此时灯光是灭的，打开灯光，并更新状态
 975   7                                  //     tmr0_set_pwm_duty(cur_pwm_duty);
 976   7                                  //     tmr1_set_pwm_duty(cur_pwm_duty);
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 17  

 977   7                                  //     yellow_light_open();
 978   7                                  //     white_light_open();
 979   7      
 980   7                                  //     light_on_off_status = 1; // 更新灯光状态
 981   7                                  // }
 982   7      
 983   7                                  if (cur_pwm_duty < PWM_MAX_DUTY_MUILTY_LIGHT)
 984   7                                  {
 985   8                                      tmr0_set_pwm_duty(++cur_pwm_duty);
 986   8                                      tmr1_set_pwm_duty(cur_pwm_duty);
 987   8                                      cur_yellow_white_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
 988   8                                      // yellow_light_open();
 989   8                                      // white_light_open();
 990   8                                  }
 991   7                                  else
 992   7                                  {
 993   8                                      // 如果已经到了最大亮度
 994   8                                  }
 995   7                              }
 996   6                              else
 997   6                              {
 998   7                                  // 如果当前是在减小亮度
 999   7                                  if (cur_pwm_duty > PWM_MIN_DUTY_YELLOW_WHITE_LIGHT)
1000   7                                  {
1001   8                                      tmr0_set_pwm_duty(--cur_pwm_duty);
1002   8                                      tmr1_set_pwm_duty(cur_pwm_duty);
1003   8                                       cur_yellow_white_duty = cur_pwm_duty; // 更新独立保存的PWM占空比
1004   8                                      // yellow_light_open();
1005   8                                      // white_light_open();
1006   8                                      // light_on_off_status = 1; // 更新灯光状态
1007   8                                  }
1008   7                                  else
1009   7                                  {
1010   8                                      // 如果已经到了最小亮度
1011   8                                      // tmr0_set_pwm_duty(cur_pwm_duty);
1012   8                                      // tmr1_set_pwm_duty(cur_pwm_duty);
1013   8                                      // yellow_light_close();
1014   8                                      // white_light_close();
1015   8                                      // light_on_off_status = 0; // 更新灯光状态
1016   8                                  }
1017   7                              }
1018   6                          }
1019   5                          else if (LIGHT_MUILTY_CUR_OFF == light_muilty_cur_status)
1020   5                          {
1021   6                              // 如果当前灯是关闭的，松开手时，把灯打开
1022   6                              is_touch_key_light_press = 1;
1023   6                              light_adjust_add_sub_flag = 1;
1024   6                          }
1025   5                      }
1026   4      #endif // 进行长按的灯光调节
1027   4      
1028   4                      // 在这里发送按键数据
1029   4                      send_key_status(TOUCH_KEY_LIGHT);
1030   4                      // delay_100us(15); // 每1.5ms调整0.1%的占空比（直接在这里调节灯光亮度才使用，在定时器里调
             -节灯光亮度可以注释掉这一行）
1031   4                      delay_100us(PWM_ADJUST_DUTY_TIME_STEP); // 每x.xms调整0.1%的占空比
1032   4                  } // 如果还不松手
1033   3      
1034   3                  // 如果长按后松手了，要更新当前是在增大亮度还是减少亮度的标志位
1035   3                  if (light_adjust_add_sub_flag)
1036   3                  {
1037   4                      // 如果之前是在增大亮度，下次长按要变成减小亮度
C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 18  

1038   4                      light_adjust_add_sub_flag = 0; // 更新标志位
1039   4                  }
1040   3                  else
1041   3                  {
1042   4                      // 如果之前是在减小亮度，下次长按要变成增大亮度
1043   4                      light_adjust_add_sub_flag = 1; // 更新标志位
1044   4                  }
1045   3              }
1046   2          }
1047   1          else if (1 == long_touch_flag && 0 == KeyOnOutput)
1048   1          {
1049   2              // 如果之前是长按，现在却松开了按键
1050   2              // switch (KeyOld)
1051   2              // {
1052   2              // case TK_CH25_VALIB:
1053   2              //     // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK1);
1054   2              //     break;
1055   2      
1056   2              // case TK_CH3_VALIB:
1057   2              //     // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK2);
1058   2              //     break;
1059   2      
1060   2              // case TK_CH2_VALIB:
1061   2              //     // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK3);
1062   2              //     break;
1063   2      
1064   2              // case TK_CH0_VALIB:
1065   2              //     // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK4);
1066   2              //     break;
1067   2      
1068   2              // case TK_CH9_VALIB:
1069   2              //     // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK5);
1070   2              //     break;
1071   2      
1072   2              // case TK_CH10_VALIB:
1073   2              //     // send_status_keyval(KEY_PRESS_LOOSE, KEY_TK6);
1074   2              //     break;
1075   2              // }
1076   2      
1077   2              // is_touch_key_light_hold = 0; // 清除灯光按键长按的标志位，表示未长按
1078   2      
1079   2              long_touch_flag = 0; // 清除标志位
1080   2              cnt = 0;
1081   2              KeyOld = 0;
1082   2              __tk_key_flag = 0;
1083   2          }
1084   1      #endif // 长按相关的功能
1085   1      }
1086          #endif // end of #ifdef CIRCUIT_BOARD
1087          
1088          /*************************** (C) COPYRIGHT 2022 TAIXIN-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1213    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      9       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.60.7.0   TK_USER                                                           08/09/2024 16:01:45 PAGE 19  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
