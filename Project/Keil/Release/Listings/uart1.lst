C51 COMPILER V9.60.7.0   UART1                                                             08/09/2024 10:32:37 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART1
OBJECT MODULE PLACED IN .\Release\Objects\uart1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart1.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware;..\..\Lowpower;..\..\App) INTERVAL(3) DEBUG OBJEC
                    -TEXTEND PRINT(.\Release\Listings\uart1.lst) OBJECT(.\Release\Objects\uart1.obj)

line level    source

   1          // 不能使用UART1+DMA来接收不定长的数据，这里的代码不能用
   2          #include "uart1.h"
   3          #if USE_UART1
   4          
   5          // 设置的波特率需要适配单片机的时钟，这里直接使用了官方的代码
   6          #define USER_UART1_BAUD ((SYSCLK - UART1_BAUDRATE) / (UART1_BAUDRATE))
   7          
   8          // // 用来存放接收的数据帧的缓冲区
   9          // volatile u8 uart1_recv_buf[UART1_RXBUF_LEN] = {0};
  10          // volatile u16 uart1_recv_cnt = 0;  // 接收缓冲区计数值
  11          // volatile bit uart1_recv_flag = 0; // 接收完成一帧的标志位
  12          
  13          /*
  14              // 使用示例
  15              if (uart1_recv_flag)
  16              {
  17                  uart1_recv_flag = 0;
  18                  printf("%s\n", uart1_recv_buf);
  19                  memset(uart1_recv_buf, 0, UART1_RXBUF_LEN);
  20                  uart1_recv_cnt = 0;
  21              }
  22          */
  23          
  24          #if USE_PRINTF_UART1
              // 重写putchar()函数
              char putchar(char c)
              {
                  uart1_sendbyte(c); // 调用串口1的单个字节发送函数
                  return c;
              }
              #endif // USE_PRINTF_UART1
  32          
  33          void uart1_config(void)
  34          {
  35   1          // P14为发送脚
  36   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x3) ;
  37   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x1); // 输出模式
  38   1          FOUT_S14 |= GPIO_FOUT_UART1_TX;   // 配置为UART1_TX
  39   1      
  40   1          // // P15为发送引脚
  41   1          // P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3) ;
  42   1          // P1_MD1 |= GPIO_P15_MODE_SEL(0x1); // 输出模式
  43   1          // FOUT_S15 |= GPIO_FOUT_UART1_TX;   // 配置P15为UART1_TX
  44   1      
  45   1          UART1_BAUD1 = (USER_UART1_BAUD >> 8) & 0xFF; // 配置波特率高八位
  46   1          UART1_BAUD0 = USER_UART1_BAUD & 0xFF;        // 配置波特率低八位
  47   1          UART1_CON0 = UART_STOP_BIT(0x0) |
  48   1                       UART_RX_IRQ_EN(0x1) |
  49   1                       UART_EN(0x1); // 8bit数据，1bit停止位，使能接收中断，使能串口
  50   1      }
  51          
  52          // UART1发送一个字节数据的函数
  53          void uart1_sendbyte(u8 senddata)
C51 COMPILER V9.60.7.0   UART1                                                             08/09/2024 10:32:37 PAGE 2   

  54          {
  55   1          while (!(UART1_STA & UART_TX_DONE(0x01))) // 等待前一次发送完成
  56   1              ;
  57   1          UART1_DATA = senddata;
  58   1          while (!(UART1_STA & UART_TX_DONE(0x01))) // 等待这次发送完成
  59   1              ;
  60   1      }
  61          
  62          // // UART1中断服务函数（如果使用DMA，DMA接收满才会触发该中断）
  63          // void UART1_IRQHandler(void) interrupt UART1_IRQn
  64          // {
  65          //     // 进入中断设置IP，不可删除
  66          //     __IRQnIPnPush(UART1_IRQn);
  67          
  68          //     // ---------------- 用户函数处理 -------------------
  69          
  70          //     // RX接收完成中断
  71          //     if (UART1_STA & UART_RX_DONE(0x1))
  72          //     {
  73          //         uart1_recv_buf[uart1_recv_cnt++] = UART1_DATA;
  74          //         if (UART1_DATA == '\n')
  75          //         {
  76          //             uart1_recv_flag = 1;
  77          //         }
  78          //     }
  79          
  80          //     // 退出中断设置IP，不可删除
  81          //     __IRQnIPnPop(UART1_IRQn);
  82          // }
  83          
  84          #endif // USE_UART1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     40    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
